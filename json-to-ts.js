#!/usr/bin/env node
const fs = require("fs");
const path = require("path");

class JsonToTypeScript {
  constructor(options = {}) {
    this.options = {
      rootName: options.rootName || "RootObject",
      useInterfaces: options.useInterfaces !== false,
      exportTypes: options.exportTypes !== false,
      optionalFields: options.optionalFields || false,
      ...options,
    };
  }

  // Fun√ß√£o principal para converter JSON para TypeScript
  convert(jsonInput) {
    let jsonData;

    // Parse do JSON se for string
    try {
      jsonData =
        typeof jsonInput === "string" ? JSON.parse(jsonInput) : jsonInput;
    } catch (error) {
      throw new Error(`JSON inv√°lido: ${error.message}`);
    }

    const interfaces = new Map();
    const rootType = this.generateType(
      jsonData,
      this.options.rootName,
      interfaces
    );

    // Gera o c√≥digo TypeScript
    let result = "";

    // Adiciona todas as interfaces geradas
    for (const [name, definition] of interfaces) {
      const exportKeyword = this.options.exportTypes ? "export " : "";
      const typeKeyword = this.options.useInterfaces ? "interface" : "type";

      if (this.options.useInterfaces) {
        result += `${exportKeyword}${typeKeyword} ${name} ${definition}\n\n`;
      } else {
        result += `${exportKeyword}${typeKeyword} ${name} = ${definition};\n\n`;
      }
    }

    return result.trim();
  }

  // Gera o tipo TypeScript baseado no valor
  generateType(value, typeName, interfaces) {
    if (value === null) {
      return "null";
    }

    if (Array.isArray(value)) {
      if (value.length === 0) {
        return "any[]";
      }

      const itemType = this.generateType(
        value[0],
        `${typeName}Item`,
        interfaces
      );
      return `${itemType}[]`;
    }

    if (typeof value === "object") {
      const properties = [];

      for (const [key, val] of Object.entries(value)) {
        const propertyType = this.generateType(
          val,
          this.capitalize(key),
          interfaces
        );
        const optional = this.options.optionalFields ? "?" : "";
        const safeKey = this.isValidIdentifier(key) ? key : `"${key}"`;
        properties.push(`  ${safeKey}${optional}: ${propertyType};`);
      }

      const interfaceDefinition = `{\n${properties.join("\n")}\n}`;
      interfaces.set(typeName, interfaceDefinition);

      return typeName;
    }

    // Tipos primitivos
    return this.getPrimitiveType(value);
  }

  // Retorna o tipo primitivo TypeScript
  getPrimitiveType(value) {
    if (typeof value === "string") return "string";
    if (typeof value === "number") return "number";
    if (typeof value === "boolean") return "boolean";
    return "any";
  }

  // Capitaliza a primeira letra
  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  // Verifica se √© um identificador v√°lido
  isValidIdentifier(str) {
    return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(str);
  }
}

// Fun√ß√£o para uso em linha de comando
function cli() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log(`
Uso: node json-to-ts.js [op√ß√µes] <arquivo-json | json-string>

Op√ß√µes:
  --root-name <nome>     Nome da interface/tipo raiz (padr√£o: "RootObject")
  --use-types           Usar type ao inv√©s de interface
  --no-export           N√£o adicionar export nas defini√ß√µes
  --optional            Tornar todos os campos opcionais
  --output <arquivo>    Salvar resultado em arquivo
  
Exemplos:
  node json-to-ts.js data.json
  node json-to-ts.js '{"name": "Jo√£o", "age": 30}'
  node json-to-ts.js --root-name User --output types.ts user.json
    `);
    return;
  }

  const options = {};
  let inputFile = null;
  let outputFile = null;
  let jsonString = null;
  let inputArgs = [];

  // Parse dos argumentos
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    switch (arg) {
      case "--root-name":
        options.rootName = args[++i];
        break;
      case "--use-types":
        options.useInterfaces = false;
        break;
      case "--no-export":
        options.exportTypes = false;
        break;
      case "--optional":
        options.optionalFields = true;
        break;
      case "--output":
        outputFile = args[++i];
        break;
      default:
        if (!arg.startsWith("--")) {
          inputArgs.push(arg);
        }
    }
  }

  // Processar argumentos de input
  for (const inputArg of inputArgs) {
    if (fs.existsSync(inputArg)) {
      inputFile = inputArg;
      console.log(`üìÅ Arquivo encontrado: ${inputArg}`);
      break;
    } else if (inputArg.startsWith("{") || inputArg.startsWith("[")) {
      jsonString = inputArg;
      console.log(`üìù JSON string detectado`);
      break;
    }
  }

  // Se n√£o encontrou arquivo nem JSON, tenta o √∫ltimo argumento como arquivo
  if (!inputFile && !jsonString && inputArgs.length > 0) {
    const lastArg = inputArgs[inputArgs.length - 1];
    console.log(`üîç Tentando arquivo: ${lastArg}`);

    if (fs.existsSync(lastArg)) {
      inputFile = lastArg;
    } else {
      console.error(`‚ùå Arquivo n√£o encontrado: ${lastArg}`);
      console.log(
        "üí° Certifique-se de que o arquivo existe no diret√≥rio atual"
      );
      console.log(`üìç Diret√≥rio atual: ${process.cwd()}`);
      console.log(
        `üìÇ Arquivos dispon√≠veis: ${
          fs
            .readdirSync(".")
            .filter((f) => f.endsWith(".json"))
            .join(", ") || "nenhum .json"
        }`
      );
      process.exit(1);
    }
  }

  try {
    const converter = new JsonToTypeScript(options);
    let jsonData;

    // L√™ o input
    if (inputFile) {
      console.log(`üìñ Lendo arquivo: ${inputFile}`);
      const content = fs.readFileSync(inputFile, "utf8");
      jsonData = content;
    } else if (jsonString) {
      console.log(`üîÑ Processando JSON string`);
      jsonData = jsonString;
    } else {
      throw new Error("Nenhum input fornecido. Use --help para ver exemplos.");
    }

    console.log(`üîß Convertendo com op√ß√µes: ${JSON.stringify(options)}`);

    // Converte
    const result = converter.convert(jsonData);

    // Output
    if (outputFile) {
      fs.writeFileSync(outputFile, result);
      console.log(`‚úÖ Tipos TypeScript gerados em: ${outputFile}`);
      console.log(`üìè Tamanho do arquivo: ${result.length} caracteres`);
    } else {
      console.log("\n" + "=".repeat(50));
      console.log("üìã RESULTADO TYPESCRIPT:");
      console.log("=".repeat(50));
      console.log(result);
      console.log("=".repeat(50));
    }
  } catch (error) {
    console.error(`‚ùå Erro: ${error.message}`);

    if (error.message.includes("JSON inv√°lido")) {
      console.log("üí° Dicas para corrigir JSON:");
      console.log("  - Verifique se todas as chaves est√£o entre aspas duplas");
      console.log("  - Certifique-se de que n√£o h√° v√≠rgulas extras");
      console.log("  - Use aspas duplas (\") ao inv√©s de aspas simples (')");
    }

    process.exit(1);
  }
}

// Fun√ß√£o para uso program√°tico em React/Node
function convertJsonToTs(json, options = {}) {
  const converter = new JsonToTypeScript(options);
  return converter.convert(json);
}

// Se executado diretamente
if (require.main === module) {
  cli();
}

// Exporta para uso como m√≥dulo
module.exports = {
  JsonToTypeScript,
  convertJsonToTs,
  cli,
};

// Exemplo de uso program√°tico:
/*
const { convertJsonToTs } = require('./json-to-ts');

const json = {
  name: "Jo√£o",
  age: 30,
  hobbies: ["leitura", "programa√ß√£o"],
  address: {
    street: "Rua A",
    number: 123
  }
};

const types = convertJsonToTs(json, {
  rootName: 'User',
  exportTypes: true
});

console.log(types);
*/
